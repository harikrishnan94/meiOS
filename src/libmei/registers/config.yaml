output: generated/config.h

namespaces:
  - namespace:
      name: mei::registers::config
      registers:
        # System Control Register - EL1
        #
        # Provides top level control of the system, including its memory system, at EL1 and EL0.
        - register:
            name: SCTLR_EL1
            type: u64
            system_name: SCTLR_EL1
            fields:
              # Traps EL0 execution of cache maintenance instructions to EL1, from AArch64 state only.
              #
              # 0 Any attempt to execute a DC CVAU, DC CIVAC, DC CVAC, DC CVAP, or IC IVAU
              #   instruction at EL0 using AArch64 is trapped to EL1.
              # 1 This control does not cause any instructions to be trapped.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on execution at EL0.
              #
              # If the Point of Coherency is before any level of data cache, it is IMPLEMENTATION DEFINED whether
              # the execution of any data or unified cache clean, or clean and invalidate instruction that operates by
              # VA to the point of coherency can be trapped when the value of this control is 1.
              #
              # If the Point of Unification is before any level of data cache, it is IMPLEMENTATION DEFINED whether
              # the execution of any data or unified cache clean by VA to the point of unification instruction can be
              # trapped when the value of this control is 1.
              #
              # If the Point of Unification is before any level of instruction cache, it is IMPLEMENTATION DEFINED
              # whether the execution of any instruction cache invalidate by VA to the point of unification
              # instruction can be trapped when the value of this control is 1.
              - UCI:
                26,1:
                  Trap: 0
                  DontTrap: 1

              # Endianness of data accesses at EL1, and stage 1 translation table walks in the EL1&0 translation regime.
              #
              # 0 Explicit data accesses at EL1, and stage 1 translation table walks in the EL1&0
              #   translation regime are little-endian.
              # 1 Explicit data accesses at EL1, and stage 1 translation table walks in the EL1&0
              #   translation regime are big-endian.
              #
              # If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this
              # bit is RES 0.
              #
              # If an implementation does not provide Little-endian support at Exception Levels higher than EL0
              # this bit is RES 1.
              #
              # The EE bit is permitted to be cached in a TLB.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on the PE.
              - EE:
                25,1:
                  LittleEndian: 0
                  BigEndian: 1

              # Endianness of data accesses at EL0.
              #
              # 0 Explicit data accesses at EL0 are little-endian.
              #
              # 1 Explicit data accesses at EL0 are big-endian.
              #
              # If an implementation only supports Little-endian accesses at EL0 then this bit is RES 0. This option
              # is not permitted when SCTLR_EL1.EE is RES 1.
              #
              # If an implementation only supports Big-endian accesses at EL0 then this bit is RES 1. This option is
              # not permitted when SCTLR_EL1.EE is RES 0.
              #
              # This bit has no effect on the endianness of LDTR , LDTRH , LDTRSH , LDTRSW , STTR , and STTRH instructions
              # executed at EL1.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on execution at EL0.
              - E0E:
                24,1:
                  LittleEndian: 0
                  BigEndian: 1

              # Write permission implies XN (Execute-never). For the EL1&0 translation regime, this bit can force
              # all memory regions that are writable to be treated as XN.
              #
              # 0 This control has no effect on memory access permissions.
              #
              # 1 Any region that is writable in the EL1&0 translation regime is forced to XN for accesses
              #   from software executing at EL1 or EL0.
              #
              # The WXN bit is permitted to be cached in a TLB.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on the PE.
              - WXN:
                19,1:
                  Disable: 0
                  Enable: 1

              # Traps EL0 execution of WFE instructions to EL1, from both Execution states.
              #
              # 0 Any attempt to execute a WFE instruction at EL0 is trapped to EL1, if the instruction
              #   would otherwise have caused the PE to enter a low-power state.
              #
              # 1 This control does not cause any instructions to be trapped.
              #
              # In AArch32 state, the attempted execution of a conditional WFE instruction is only trapped if the
              # instruction passes its condition code check.
              #
              # **Note:**
              #
              # Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of
              # WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup
              # event. The only guarantee is that if the instruction does not complete in finite time in the
              # absence of a Wakeup event, the trap will be taken.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on execution at EL0.
              - NTWE:
                18,1:
                  Trap: 0
                  DontTrap: 1

              # Traps EL0 executions of WFI instructions to EL1, from both execution states:
              #
              # 0 Any attempt to execute a WFI instruction at EL0 is trapped EL1, if the instruction would
              #   otherwise have caused the PE to enter a low-power state.
              #
              # 1 This control does not cause any instructions to be trapped.
              #
              # In AArch32 state, the attempted execution of a conditional WFI instruction is only trapped if the
              # instruction passes its condition code check.
              #
              # **Note:**
              #
              # Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of
              # WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup
              # event. The only guarantee is that if the instruction does not complete in finite time in the
              # absence of a Wakeup event, the trap will be taken.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on execution at EL0.
              - NTWI:
                16,1:
                  Trap: 0
                  DontTrap: 1

              # Traps EL0 accesses to the CTR_EL0 to EL1, from AArch64 state only.
              #
              # 0 Accesses to the CTR_EL0 from EL0 using AArch64 are trapped to EL1.
              #
              # 1 This control does not cause any instructions to be trapped.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on execution at EL0.
              - UCT:
                15,1:
                  Trap: 0
                  DontTrap: 1

              # Traps EL0 execution of DC ZVA instructions to EL1, from AArch64 state only.
              #
              # 0 Any attempt to execute a DC ZVA instruction at EL0 using AArch64 is trapped to EL1.
              #   Reading DCZID_EL0.DZP from EL0 returns 1, indicating that DC ZVA instructions
              #   are not supported.
              #
              # 1 This control does not cause any instructions to be trapped.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on execution at EL0.
              - DZE:
                14,1:
                  Trap: 0
                  DontTrap: 1

              # Instruction access Cacheability control, for accesses at EL0 and
              # EL1:
              #
              # 0 All instruction access to Normal memory from EL0 and EL1 are Non-cacheable for all
              #   levels of instruction and unified cache.
              #
              #   If the value of SCTLR_EL1.M is 0, instruction accesses from stage 1 of the EL1&0
              #   translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer
              #   Non-cacheable memory.
              #
              # 1 This control has no effect on the Cacheability of instruction access to Normal memory
              #   from EL0 and EL1.
              #
              #   If the value of SCTLR_EL1.M is 0, instruction accesses from stage 1 of the EL1&0
              #   translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer
              #   Write-Through memory.
              #
              # When the value of the HCR_EL2.DC bit is 1, then instruction access to Normal memory from
              # EL0 and EL1 are Cacheable regardless of the value of the SCTLR_EL1.I bit.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on the PE.
              #
              # When this register has an architecturally-defined reset value, this field resets to 0.
              - I:
                12,1:
                  NonCacheable: 0
                  Cacheable: 1

              # User Mask Access. Traps EL0 execution of MSR and MRS instructions that access the
              # PSTATE.{D, A, I, F} masks to EL1, from AArch64 state only.
              #
              # 0 Any attempt at EL0 using AArch64 to execute an MRS , MSR(register) , or MSR(immediate)
              #   instruction that accesses the [`DAIF`](module@super::super::DAIF) is trapped to EL1.
              #
              # 1 This control does not cause any instructions to be trapped.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on execution at EL0.
              - UMA:
                9,1:
                  Trap: 0
                  DontTrap: 1

              # Non-aligned access. This bit controls generation of Alignment faults at EL1 and EL0 under certain conditions.
              #
              # LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH
              # STLLR, STLLRH, STLR, STLRH, STLUR, and STLURH will or will not generate an Alignment
              # fault if all bytes being accessed are not within a single 16-byte quantity
              # aligned to 16 bytes for accesses.
              - NAA:
                6,1:
                  Disable: 0
                  Enable: 1

              # SP Alignment check enable for EL0.
              #
              # When set to 1, if a load or store instruction executed at EL0 uses the SP
              # as the base address and the SP is not aligned to a 16-byte boundary
              # then a SP alignment fault exception is generated.
              - SA0:
                4,1:
                  Disable: 0
                  Enable: 1

              # SP Alignment check enable.
              #
              # When set to 1, if a load or store instruction executed at EL1 uses the SP
              # as the base address and the SP is not aligned to a 16-byte boundary
              # then a SP alignment fault exception is generated.
              - SA:
                3,1:
                  Disable: 0
                  Enable: 1

              # Cacheability control, for data accesses.
              #
              # 0 All data access to Normal memory from EL0 and EL1, and all Normal memory accesses to
              #   the EL1&0 stage 1 translation tables, are Non-cacheable for all levels of data and
              #   unified cache.
              #
              # 1 This control has no effect on the Cacheability of:
              #   - Data access to Normal memory from EL0 and EL1.
              #   - Normal memory accesses to the EL1&0 stage 1 translation tables.
              #
              # When the value of the HCR_EL2.DC bit is 1, the PE ignores SCLTR.C. This means that
              # Non-secure EL0 and Non-secure EL1 data accesses to Normal memory are Cacheable.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit
              # has no effect on the PE.
              #
              # When this register has an architecturally-defined reset value, this field resets to 0.
              - C:
                2,1:
                  NonCacheable: 0
                  Cacheable: 1

              # Alignment check enable. This is the enable bit for Alignment fault checking at EL1 and EL0.
              #
              # Instructions that load or store one or more registers, other than load/store exclusive
              # and load-acquire/store-release, will or will not check that the address being accessed
              # is aligned to the size of the data element(s) being accessed depending on this flag.
              #
              # Load/store exclusive and load-acquire/store-release instructions have an alignment check
              # regardless of the value of the A bit.
              - A:
                1,1:
                  Disable: 0
                  Enable: 1

              # MMU enable for EL1 and EL0 stage 1 address translation. Possible values of this bit are:
              #
              # 0 EL1 and EL0 stage 1 address translation disabled.
              #   - See the SCTLR_EL1.I field for the behavior of instruction accesses to Normal memory.
              #
              # 1 EL1 and EL0 stage 1 address translation enabled.
              - M:
                0,1:
                  Disable: 0
                  Enable: 1

        # Hypervisor Configuration Register - EL2
        # Provides configuration controls for virtualization, including defining
        # whether various Non-secure operations are trapped to EL2.
        - register:
            name: HCR_EL2
            type: u64
            system_name: HCR_EL2
            fields:
              # When FEAT_S2FWB is implemented Forced Write-back changes the combined cachability of stage1
              # and stage2 attributes
              - FWB:
                46,1:
                  # Stage2 memory type and cacheability attributes are in bits[5:2] of the stage2 PTE
                  Disabled: 0
                  # Stage1 memory type can be overridden by Stage2 descriptor
                  Enabled: 1

              # Controls the use of instructions related to Pointer Authentication:
              #
              #   - In EL0, when HCR_EL2.TGE==0 or HCR_EL2.E2H==0, and the associated SCTLR_EL1.En<N><M>==1.
              #   - In EL1, the associated SCTLR_EL1.En<N><M>==1.
              #
              # Traps are reported using EC syndrome value 0x09. The Pointer Authentication instructions
              # trapped are:
              #
              # `AUTDA`, `AUTDB`, `AUTDZA`, `AUTDZB`, `AUTIA`, `AUTIA1716`, `AUTIASP`, `AUTIAZ`, `AUTIB`, `AUTIB1716`
              # `AUTIBSP`, `AUTIBZ`, `AUTIZA`, `AUTIZB`, `PACGA`, `PACDA`, `PACDB`, `PACDZA`, `PACDZB`, `PACIA`
              # `PACIA1716`, `PACIASP`, `PACIAZ`, `PACIB`, `PACIB1716`, `PACIBSP`, `PACIBZ`, `PACIZA`, `PACIZB`
              # `RETAA`, `RETAB`, `BRAA`, `BRAB`, `BLRAA`, `BLRAB`, `BRAAZ`, `BRABZ`, `BLRAAZ`, `BLRABZ`
              # `ERETAA`, `ERETAB`, `LDRAA`, and `LDRAB`.
              - API:
                41,1:
                  EnableTrapPointerAuthInstToEl2: 0
                  DisableTrapPointerAuthInstToEl2: 1

              # Trap registers holding "key" values for Pointer Authentication. Traps accesses to the
              # following registers from EL1 to EL2, when EL2 is enabled in the current Security state
              # reported using EC syndrome value 0x18:
              #
              # `APIAKeyLo_EL1`, `APIAKeyHi_EL1`, `APIBKeyLo_EL1`, `APIBKeyHi_EL1`, `APDAKeyLo_EL1`
              # `APDAKeyHi_EL1`, `APDBKeyLo_EL1`, `APDBKeyHi_EL1`, `APGAKeyLo_EL1`, and `APGAKeyHi_EL1`.
              - APK:
                40,1:
                  EnableTrapPointerAuthKeyRegsToEl2: 0
                  DisableTrapPointerAuthKeyRegsToEl2: 1

              # Route synchronous External abort exceptions to EL2.
              #   if 0: This control does not cause exceptions to be routed from EL0 and EL1 to EL2.
              #   if 1: Route synchronous External abort exceptions from EL0 and EL1 to EL2, when EL2 is
              #         enabled in the current Security state, if not routed to EL3.
              - TEA:
                37,1:
                  DisableTrapSyncExtAbortsToEl2: 0
                  EnableTrapSyncExtAbortsToEl2: 1

              # EL2 Host. Enables a configuration where a Host Operating System is running in EL2, and
              # the Host Operating System's applications are running in EL0.
              - E2H:
                34,1:
                  DisableOsAtEl2: 0
                  EnableOsAtEl2: 1

              # Execution state control for lower Exception levels:
              #
              # 0 Lower levels are all AArch32.
              # 1 The Execution state for EL1 is AArch64. The Execution state for EL0 is determined by
              #   the current value of PSTATE.nRW when executing at EL0.
              #
              # If all lower Exception levels cannot use AArch32 then this bit is RAO/WI.
              #
              # In an implementation that includes EL3, when SCR_EL3.NS==0, the PE behaves as if this
              # bit has the same value as the SCR_EL3.RW bit for all purposes other than a direct read
              # or write access of HCR_EL2.
              #
              # The RW bit is permitted to be cached in a TLB.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this
              # field behaves as 1 for all purposes other than a direct read of the value of this bit.
              - RW:
                31,1:
                  AllLowerELsAreAarch32: 0
                  EL1IsAarch64: 1

              # Trap General Exceptions, from EL0.
              #
              # If enabled:
              #   - When EL2 is not enabled in the current Security state, this control has no effect on
              #     execution at EL0.
              #
              #   - When EL2 is enabled in the current Security state, in all cases:
              #
              #       - All exceptions that would be routed to EL1 are routed to EL2.
              #       - If EL1 is using AArch64, the SCTLR_EL1.M field is treated as being 0 for all
              #         purposes other than returning the result of a direct read of SCTLR_EL1.
              #       - If EL1 is using AArch32, the SCTLR.M field is treated as being 0 for all
              #         purposes other than returning the result of a direct read of SCTLR.
              #       - All virtual interrupts are disabled.
              #       - Any IMPLEMENTATION DEFINED mechanisms for signaling virtual interrupts are
              #         disabled.
              #       - An exception return to EL1 is treated as an illegal exception return.
              #       - The MDCR_EL2.{TDRA, TDOSA, TDA, TDE} fields are treated as being 1 for all
              #         purposes other than returning the result of a direct read of MDCR_EL2.
              #
              #   - In addition, when EL2 is enabled in the current Security state, if:
              #
              #       - HCR_EL2.E2H is 0, the Effective values of the HCR_EL2.{FMO, IMO, AMO} fields
              #         are 1.
              #       - HCR_EL2.E2H is 1, the Effective values of the HCR_EL2.{FMO, IMO, AMO} fields
              #         are 0.
              #
              #   - For further information on the behavior of this bit when E2H is 1, see 'Behavior of
              #     HCR_EL2.E2H'.
              - TGE:
                27,1:
                  DisableTrapGeneralExceptionsToEl2: 0
                  EnableTrapGeneralExceptionsToEl2: 1

              # Default Cacheability.
              #
              # 0 This control has no effect on the Non-secure EL1&0 translation regime.
              #
              # 1 In Non-secure state:
              #   - When EL1 is using AArch64, the PE behaves as if the value of the SCTLR_EL1.M field
              #     is 0 for all purposes other than returning the value of a direct read of SCTLR_EL1.
              #
              #   - When EL1 is using AArch32, the PE behaves as if the value of the SCTLR.M field is 0
              #     for all purposes other than returning the value of a direct read of SCTLR.
              #
              #   - The PE behaves as if the value of the HCR_EL2.VM field is 1 for all purposes other
              #     than returning the value of a direct read of HCR_EL2.
              #
              #   - The memory type produced by stage 1 of the EL1&0 translation regime is Normal
              #     Non-Shareable, Inner Write-Back Read-Allocate Write-Allocate, Outer Write-Back
              #     Read-Allocate Write-Allocate.
              #
              # This field has no effect on the EL2, EL2&0, and EL3 translation regimes.
              #
              # This field is permitted to be cached in a TLB.
              #
              # In an implementation that includes EL3, when the value of SCR_EL3.NS is 0 the PE behaves
              # as if this field is 0 for all purposes other than a direct read or write access of
              # HCR_EL2.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this
              # field behaves as 0 for all purposes other than a direct read of the value of this field.
              - DC: 12,1

              # Physical SError interrupt routing.
              #   - If bit is 1 when executing at any Exception level, and EL2 is enabled in the current
              #     Security state:
              #     - Physical SError interrupts are taken to EL2, unless they are routed to EL3.
              #     - When the value of HCR_EL2.TGE is 0, then virtual SError interrupts are enabled.
              - AMO: 5,1

              # Physical IRQ Routing.
              #
              # If this bit is 0:
              #   - When executing at Exception levels below EL2, and EL2 is enabled in the current
              #     Security state:
              #     - When the value of HCR_EL2.TGE is 0, Physical IRQ interrupts are not taken to EL2.
              #     - When the value of HCR_EL2.TGE is 1, Physical IRQ interrupts are taken to EL2
              #       unless they are routed to EL3.
              #     - Virtual IRQ interrupts are disabled.
              #
              # If this bit is 1:
              #   - When executing at any Exception level, and EL2 is enabled in the current Security
              #     state:
              #     - Physical IRQ interrupts are taken to EL2, unless they are routed to EL3.
              #     - When the value of HCR_EL2.TGE is 0, then Virtual IRQ interrupts are enabled.
              #
              # If EL2 is enabled in the current Security state, and the value of HCR_EL2.TGE is 1:
              #   - Regardless of the value of the IMO bit, physical IRQ Interrupts target EL2 unless
              #     they are routed to EL3.
              #   - When FEAT_VHE is not implemented, or if HCR_EL2.E2H is 0, this field behaves as 1
              #     for all purposes other than a direct read of the value of this bit.
              #   - When FEAT_VHE is implemented and HCR_EL2.E2H is 1, this field behaves as 0 for all
              #     purposes other than a direct read of the value of this bit.
              #
              # For more information, see 'Asynchronous exception routing'.
              - IMO:
                4,1:
                  DisableVirtualIRQ: 0
                  EnableVirtualIRQ: 1

              # Physical FIQ Routing.
              # If this bit is 0:
              #   - When executing at Exception levels below EL2, and EL2 is enabled in the current
              #     Security state:
              #     - When the value of HCR_EL2.TGE is 0, Physical FIQ interrupts are not taken to EL2.
              #     - When the value of HCR_EL2.TGE is 1, Physical FIQ interrupts are taken to EL2
              #       unless they are routed to EL3.
              #     - Virtual FIQ interrupts are disabled.
              #
              # If this bit is 1:
              #   - When executing at any Exception level, and EL2 is enabled in the current Security
              #     state:
              #     - Physical FIQ interrupts are taken to EL2, unless they are routed to EL3.
              #     - When HCR_EL2.TGE is 0, then Virtual FIQ interrupts are enabled.
              #
              # If EL2 is enabled in the current Security state and the value of HCR_EL2.TGE is 1:
              #   - Regardless of the value of the FMO bit, physical FIQ Interrupts target EL2 unless
              #     they are routed to EL3.
              #   - When FEAT_VHE is not implemented, or if HCR_EL2.E2H is 0, this field behaves as 1
              #     for all purposes other than a direct read of the value of this bit.
              #   - When FEAT_VHE is implemented and HCR_EL2.E2H is 1, this field behaves as 0 for all
              #     purposes other than a direct read of the value of this bit.
              #
              # For more information, see 'Asynchronous exception routing'.
              - FMO:
                3,1:
                  DisableVirtualFIQ: 0
                  EnableVirtualFIQ: 1

              # Set/Way Invalidation Override. Causes Non-secure EL1 execution of the data cache
              # invalidate by set/way instructions to perform a data cache clean and invalidate by
              # set/way:
              #
              # 0 This control has no effect on the operation of data cache invalidate by set/way
              #   instructions.
              #
              # 1 Data cache invalidate by set/way instructions perform a data cache clean and
              #   invalidate by set/way.
              #
              # When the value of this bit is 1:
              #
              # AArch32: DCISW performs the same invalidation as a DCCISW instruction.
              #
              # AArch64: DC ISW performs the same invalidation as a DC CISW instruction.
              #
              # This bit can be implemented as RES 1.
              #
              # In an implementation that includes EL3, when the value of SCR_EL3.NS is 0 the PE behaves
              # as if this field is 0 for all purposes other than a direct read or write access of
              # HCR_EL2.
              #
              # When HCR_EL2.TGE is 1, the PE ignores the value of this field for all purposes other
              # than a direct read of this field.
              - SWIO: 1,1

              # Virtualization enable. Enables stage 2 address translation for the EL1&0 translation regime
              # when EL2 is enabled in the current Security state. The possible values are:
              #
              # 0    EL1&0 stage 2 address translation disabled.
              # 1    EL1&0 stage 2 address translation enabled.
              #
              # When the value of this bit is 1, data cache invalidate instructions executed at EL1 perform
              # a data cache clean and invalidate. For the invalidate by set/way instruction this behavior
              # applies regardless of the value of the HCR_EL2.SWIO bit.
              #
              # This bit is permitted to be cached in a TLB.
              #
              # When ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this
              # field behaves as 0 for all purposes other than a direct read of the value of this field.
              - VM:
                0,1:
                  Disable: 0
                  Enable: 1
